<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>千摆渡的自我介绍</title>
    <url>/2020/06/01/%E5%8D%83%E6%91%86%E6%B8%A1%E7%9A%84%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浙江某不知名高校一计算机科学与技术的咸鱼学生，啥都不会的学生，去过QHD，NJ，SY的icpc现场（有点点怀念），现在正在准备考研之中，偶尔网上冲浪，喜欢看动漫，韩剧（没想到吧），偶尔打打游戏，还喜欢运动，健身（hhh），喜欢的音乐很多，不一一列举了。家住绍兴某一不知名古镇（安昌古镇）边上，放一张图</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/06/01/KYpI5Pt19gNfZFq.jpg" alt="IMG_7011.JPG"></p>
<p>其实也还可以啦，我感觉还不错。</p>
<p>既然放了家乡的照片，学校的照片怎么也得放几张了吧</p>
<p><img src="https://i.loli.net/2020/06/01/gt21Y5WZbRiBHwj.jpg" alt="IMG_0627.JPG"></p>
<p>然后自己呢，放一张没脸的照片吧hhh</p>
<p><img src="https://i.loli.net/2020/06/01/fzOY4omdHrSBaj9.jpg" alt="IMG_9195.JPG"></p>
]]></content>
      <categories>
        <category>闲话</category>
      </categories>
      <tags>
        <tag>自我介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>About me</title>
    <url>/2020/06/01/about/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>A Coder, live in Hangzhou, China.</p>
</blockquote>
<p>姓名：gjw<br>昵称：千摆渡<br>现居：杭州某大学<br>QQ：1012198609</p>
<a id="more"></a>

<img src="https://i.loli.net/2020/06/01/fzOY4omdHrSBaj9.jpg" alt="avatar" width="300" style="border-radius:50%">
]]></content>
  </entry>
  <entry>
    <title>数据结构——栈和队列</title>
    <url>/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><h3 id="3-1-1-栈的基本概念"><a href="#3-1-1-栈的基本概念" class="headerlink" title="3.1.1 栈的基本概念"></a>3.1.1 栈的基本概念</h3><p>1.栈的定义：只允许在一端进行插入或删除操作的线性表<br>n个不同的元素进栈，出栈元素不同排列的个数为 <img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/pic2.jpg" alt="picture_3"></p>
<a id="more"></a>
<p>2.栈的基本操作：</p>
<ul>
<li>InitStack(&amp;S):初始化一个空栈</li>
<li>StackEmpty(S):判断栈空，空返回true，否则返回false</li>
<li>Push(&amp;S,x):进栈，若栈S未满，则将x加入使之成为新栈顶</li>
<li>Pop(&amp;S,&amp;x):出栈，若栈未空，则弹出栈顶元素，并用x返回</li>
<li>GetTop(S,&amp;x):读栈顶元素</li>
<li>DestroyStack(&amp;S):销毁栈</li>
</ul>
<h3 id="3-1-2-栈的顺序存储结构"><a href="#3-1-2-栈的顺序存储结构" class="headerlink" title="3.1.2 栈的顺序存储结构"></a>3.1.2 栈的顺序存储结构</h3><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;    <span class="comment">//初始化</span></span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>)       <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[++S.top] = x;            <span class="comment">//指针先加1，再入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读栈顶元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共享栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top0,top1;  <span class="comment">//0号栈栈顶指针，1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;</span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈满的条件： top0 + 1 == top1</p>
<h3 id="3-1-3-栈的链式存储实现"><a href="#3-1-3-栈的链式存储实现" class="headerlink" title="3.1.3 栈的链式存储实现"></a>3.1.3 栈的链式存储实现</h3><p>定义(类似于单链表)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *LiStack;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h2><h3 id="3-2-1-队列的基本概念"><a href="#3-2-1-队列的基本概念" class="headerlink" title="3.2.1 队列的基本概念"></a>3.2.1 队列的基本概念</h3><p>1.队列的定义：只允许在表的一端进行插入，而在表的另一端进行删除<br>2.队列的基本操作<br>InitQueue(&amp;Q):初始化队列，构造一个空队列Q。DestroyQueue(&amp;Q):销毁队列。销毁并释放队列Q所占用的内存空间。<br>EnQueue(&amp;Q ,x):若队列Q未满，将x加入，使之成为新的队尾<br>DeQueue(&amp;Q ,&amp;x):若队列Q非空，删除队头元素，并用x返回。<br>GetHead(Q ,&amp;x):读队头元素，若队列Q非空，则将队头元素赋值给x</p>
<h3 id="3-2-2-队列的顺序存储结构"><a href="#3-2-2-队列的顺序存储结构" class="headerlink" title="3.2.2 队列的顺序存储结构"></a>3.2.2 队列的顺序存储结构</h3><p>1.队列的顺序存储</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判队空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//队满</span></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判满需要浪费一个单元的存储空间，若不能浪费，则类型中增加数据size或者添加tag(详情P79)</span></span><br></pre></td></tr></table></figure>
<p>出队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-队列的链式存储结构"><a href="#3-2-3-队列的链式存储结构" class="headerlink" title="3.2.3 队列的链式存储结构"></a>3.2.3 队列的链式存储结构</h3><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判队空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队（带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = s;       <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear = s;             <span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（不带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>) &#123;       <span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q.rear-&gt;next = s;       <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">        Q.rear = s;             <span class="comment">//修改表尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队(带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;                    <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front-&gt;next = p-&gt;next;        <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)                 <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.rear = Q.front;           <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队(不带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front;          <span class="comment">//p指向此次出队的结点</span></span><br><span class="line">    x = p-&gt;data;                    <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next;              <span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) &#123;               <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.front = <span class="literal">NULL</span>;             <span class="comment">//front和rear指向NULL</span></span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;                               </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-双端队列"><a href="#3-2-4-双端队列" class="headerlink" title="3.2.4 双端队列"></a>3.2.4 双端队列</h3><p>允许两端都可以进行入队和出队操作的队列</p>
<h2 id="3-3-栈和队列的应用"><a href="#3-3-栈和队列的应用" class="headerlink" title="3.3 栈和队列的应用"></a>3.3 栈和队列的应用</h2><h3 id="3-3-1-栈在括号匹配中的应用"><a href="#3-3-1-栈在括号匹配中的应用" class="headerlink" title="3.3.1 栈在括号匹配中的应用"></a>3.3.1 栈在括号匹配中的应用</h3><p>用栈实现括号匹配:<br>依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配。</p>
<p>匹配失败情况:</p>
<ol>
<li>左括号单身</li>
<li>右括号单身</li>
<li>左右括号不匹配</li>
</ol>
<h3 id="3-3-2-栈在表达式求值中的应用"><a href="#3-3-2-栈在表达式求值中的应用" class="headerlink" title="3.3.2 栈在表达式求值中的应用"></a>3.3.2 栈在表达式求值中的应用</h3><table>
<thead>
<tr>
<th>中缀表达式</th>
<th>后缀表达式</th>
<th>前缀表达式</th>
</tr>
</thead>
<tbody><tr>
<td>a + b</td>
<td>a b +</td>
<td>+ a b</td>
</tr>
<tr>
<td>a + b - c</td>
<td>a b + c -</td>
<td>- + a b c</td>
</tr>
<tr>
<td>a + b - c * d</td>
<td>a b + c d * -</td>
<td>- + a b * c d</td>
</tr>
</tbody></table>
<p><strong>中缀转后缀的手算方法:</strong></p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数 </li>
<li>如果还有运算符没被处理，就继续2</li>
</ol>
<blockquote>
<p>“左优先”原则:只要左边的运算符能先计算，就优先算左边的(能保证运算顺序唯一)</p>
</blockquote>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/pic1.jpg" alt="picture_1"></p>
<p><strong>后缀表达式的手算方法:</strong><br>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数</p>
<blockquote>
<p>注意:两个操作数的左右顺序</p>
</blockquote>
<p><strong>后缀表达式的机算方法</strong><br>用栈实现后缀表达式的计算:</p>
<ol>
<li>从左往右扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，并回到1;否则执行3</li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1</li>
</ol>
<p><strong>中缀表达式转前缀表达式(手算)</strong><br>中缀转前缀的手算方法:</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数 </li>
<li>如果还有运算符没被处理，就继续2<blockquote>
<p>“右优先”原则:只要右边的运算符能先计算，就优先算右边的</p>
</blockquote>
</li>
</ol>
<p><strong>前缀表达式的机算方法</strong><br>用栈实现前缀表达式的计算:</p>
<ol>
<li>从右往左扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，并回到1;否则执行3</li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1</li>
</ol>
<p><strong>中缀表达式转后缀表达式(机算)</strong><br>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。<br>从左到右处理各个元素，直到末尾。可能遇到三种情况:</p>
<ul>
<li>遇到操作数。直接加入后缀表达式。</li>
<li>遇到界限符。遇到“(”直接入栈;遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到 弹出“(”为止。注意:“(”不加入后缀表达式。</li>
<li>遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式， 若碰到“(” 或栈空则停止。之后再把当前运算符入栈。</li>
</ul>
<p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<p><strong>中缀表达式的计算(用栈实现)</strong><br>用栈实现中缀表达式的计算:</p>
<ul>
<li>初始化两个栈，操作数栈和运算符栈</li>
<li>若扫描到操作数，压入操作数栈</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈(期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈)</li>
</ul>
<h3 id="3-3-3-栈在递归中的应用"><a href="#3-3-3-栈在递归中的应用" class="headerlink" title="3.3.3 栈在递归中的应用"></a>3.3.3 栈在递归中的应用</h3><p>递归条件</p>
<ul>
<li>递归表达式（递归体）</li>
<li>边界条件（递归出口）</li>
</ul>
<p>函数调用的特点:最后被调用的函数最先执行结束(LIFO)<br>函数调用时，需要用一个“函数调用栈” 存储: </p>
<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——绪论</title>
    <url>/2020/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h2><h3 id="1-1-1-基本概念和术语"><a href="#1-1-1-基本概念和术语" class="headerlink" title="1.1.1 基本概念和术语"></a>1.1.1 基本概念和术语</h3><a id="more"></a>
<p>数据：信息的载体</p>
<p>数据元素：数据的基本单位，若干数据项组成</p>
<p>数据对象：具有<strong>相同性质</strong>的数据元素的集合</p>
<p>数据类型：一个值的集合和定义在集合上的一组操作</p>
<ul>
<li>原子类型：如int，bool</li>
<li>结构类型：如结构体。  <code>struct A{int a;int b};</code></li>
<li>抽象数据类型</li>
</ul>
<p>数据结构：相互之间存在一种或多种特定<strong>关系</strong>的集合</p>
<blockquote>
<p>数据对象是强调相同性质，数据结构是强调特定关系</p>
</blockquote>
<p><img src="/2020/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/a.jpg" alt="数据关系"></p>
<h3 id="1-1-2数据结构的三要素"><a href="#1-1-2数据结构的三要素" class="headerlink" title="1.1.2数据结构的三要素"></a>1.1.2数据结构的三要素</h3><p>数据的逻辑结构</p>
<ul>
<li>集合</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图状或网状结构</li>
</ul>
<p>数据的存储结构</p>
<ul>
<li>顺序存储：相邻的存储单元</li>
<li>链式存储：不要求物理位置相邻</li>
<li>索引存储：建立索引表</li>
<li>散列存储：关键字直接计算，又称哈希存储</li>
</ul>
<p>数据的运算</p>
<ul>
<li><p>运算的定义是针对逻辑结构的</p>
</li>
<li><p>运算的实现是针对存储结构的</p>
<hr>
</li>
</ul>
<h2 id="1-2-算法和算法评价"><a href="#1-2-算法和算法评价" class="headerlink" title="1.2 算法和算法评价"></a>1.2 算法和算法评价</h2><h3 id="1-2-1-算法的基本概念"><a href="#1-2-1-算法的基本概念" class="headerlink" title="1.2.1 算法的基本概念"></a>1.2.1 算法的基本概念</h3><p>程序=数据结构+算法</p>
<ul>
<li>数据结构是要处理的信息</li>
<li>算法是处理信息的步骤</li>
</ul>
<p>算法的特性</p>
<ul>
<li>有穷性：有穷时间完成</li>
<li>确定性：确切的含义，相同输入得到相同输出</li>
<li>可行性：有限次数</li>
<li>输入</li>
<li>输出</li>
</ul>
<p>好算法的目标</p>
<ul>
<li>正确性：正确的解决问题</li>
<li>可读性：良好的可读，帮助理解，无歧义</li>
<li>健壮性：非法数据，做出反应和处理</li>
<li>效率与低存储量需求：低时间，低存储</li>
</ul>
<h3 id="1-2-2-算法效率的度量"><a href="#1-2-2-算法效率的度量" class="headerlink" title="1.2.2 算法效率的度量"></a>1.2.2 算法效率的度量</h3><p>时间复杂度</p>
<ul>
<li>T(n) = O(f(n))</li>
</ul>
<p>运算规则：</p>
<ul>
<li>加法规则：T(n) = T<sub>1</sub>(n) + T<sub>2</sub>(n) = O(f(n)) + O(g(n)) = O(max(f(n),g(n)))</li>
<li>乘法规则：T(n) = T<sub>1</sub>(n) * T<sub>2</sub>(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n)) </li>
</ul>
<p>空间复杂度</p>
<ul>
<li>S(n) = O(g(n))</li>
</ul>
<p><strong>原地工作：算法所需的辅助空间为常量，即O(1)</strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>绪论</tag>
      </tags>
  </entry>
  <entry>
    <title>百度云倍速</title>
    <url>/2020/06/14/%E7%99%BE%E5%BA%A6%E4%BA%91%E5%80%8D%E9%80%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>百度云盘播放倍速需要VIP，考研党看视频课一倍速太慢需要提提速，又不想用插件，使用这个试试吧</p>
<a id="more"></a>
<p>浏览器：Chrome，火狐等</p>
<p>方法：打开检查中的console，以mac中的chrome为例如图：<br><img src="/2020/06/14/%E7%99%BE%E5%BA%A6%E4%BA%91%E5%80%8D%E9%80%9F/hello.jpg" alt="你想输入的替代文字"></p>
<p>输入如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">videojs.getPlayers(<span class="string">"video-player"</span>).html5player.tech_.setPlaybackRate(<span class="number">1.5</span>)</span><br></pre></td></tr></table></figure>

<p>1.5就是倍速，可以根据自己的要求改变</p>
<p><strong>PS：输入代码的时候必须要在视频播放的时候，先播放再放入代码并按下回车</strong></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>视频播放</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——线性表</title>
    <url>/2020/06/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的定义和基本操作"><a href="#2-1-线性表的定义和基本操作" class="headerlink" title="2.1 线性表的定义和基本操作"></a>2.1 线性表的定义和基本操作</h2><h3 id="2-1-1-线性表的定义"><a href="#2-1-1-线性表的定义" class="headerlink" title="2.1.1 线性表的定义"></a>2.1.1 线性表的定义</h3><a id="more"></a>
<p><strong>线性表</strong>是具有<strong>相同数据类型</strong>的n个数据元素的<strong>有限</strong>序列，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则其一般表示为</p>
<center>L = (a<sub>1</sub>,a<sub>2</sub>...a<sub>i</sub>,a<sub>i+1</sub>...,a<sub>n</sub>)</center>

<ul>
<li>a<sub>1</sub>:表头元素</li>
<li>a<sub>n</sub>:表尾元素</li>
</ul>
<p>除第一个元素外，每个元素<strong>有且仅有</strong>一个<strong>直接前驱</strong><br>除最后一个元素外，每个元素<strong>有且仅有</strong>一个<strong>直接后继</strong></p>
<p>特点</p>
<ul>
<li>表中元素的个数有限</li>
<li>表中元素具有逻辑上的顺序性，表中元素有其先后次序</li>
<li>表中元素都是数据元素，每个元素都是单个元素</li>
<li>表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间</li>
<li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容</li>
</ul>
<hr>
<h2 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的顺序表示</h2><h3 id="2-2-1-顺序表的定义"><a href="#2-2-1-顺序表的定义" class="headerlink" title="2.2.1 顺序表的定义"></a>2.2.1 顺序表的定义</h3><p>线性表是具有相同数据类型的n (n≥0)个数据元素的<strong>有限</strong>序列</p>
<p>特点：表中元素的逻辑顺序与其物理顺序相同</p>
<h4 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50              <span class="comment">//定义的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                </span><br><span class="line">    ElemType data[MaxSize];     <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="keyword">int</span> length;                 <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                        <span class="comment">//顺序表的类型定义</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化一个线性表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50             </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                </span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];     </span><br><span class="line">    <span class="keyword">int</span> length;                 </span><br><span class="line">&#125;SqList; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) </span><br><span class="line">        L.data[i] = <span class="number">0</span>;          <span class="comment">//将所有数据元素设置为默认值</span></span><br><span class="line">    L.length = <span class="number">0</span>;               <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">   <span class="comment">// ...未完待续</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;：对参数的修改结果需要带回来</p>
<h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10             <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *data;             <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;                 <span class="comment">//顺序表的类型定义（动态分配方式）</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure>
<p><strong>动态增加数组的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10             <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;                  <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;                 <span class="comment">//顺序表的类型定义（动态分配方式）</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="keyword">int</span> len)</span> </span>&#123;             <span class="comment">//增加动态数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> *p = L.data;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((L.MaxSize +　len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; L.length; i++) &#123;</span><br><span class="line">        L.data[i] = p[i];                           <span class="comment">//将数据复制到新区域（时间开销大）</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = L.MaxSize + len;                    <span class="comment">//顺序表最大长度增加len</span></span><br><span class="line">    <span class="built_in">free</span>(p);                                        <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>malloc和free函数的头文件<code>#include&lt;stdlib.h&gt;</code></p>
<h3 id="2-2-2-顺序表上基本操作的实现"><a href="#2-2-2-顺序表上基本操作的实现" class="headerlink" title="2.2.2 顺序表上基本操作的实现"></a>2.2.2 顺序表上基本操作的实现</h3><p><strong>插入操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemeType int             </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemeType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在顺序表L的第i个位置插入新元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)          <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= MaxSize)                <span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)     <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;                      <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;                             <span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>删除操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, <span class="keyword">int</span>&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)          <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];                      <span class="comment">//将被删除的的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++)      <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    L.length--;                             <span class="comment">//线性表的长度减1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>按位查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p><strong>按值查找（顺序查找）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)          <span class="comment">//下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<hr>
<h2 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h2><h3 id="2-3-1-单链表的定义"><a href="#2-3-1-单链表的定义" class="headerlink" title="2.3.1 单链表的定义"></a>2.3.1 单链表的定义</h3><p><strong>定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<p><strong>不带头结点的单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;<span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">return</span> (L == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList L;                             <span class="comment">//申明一个指向单链表的指针</span></span><br><span class="line">    InitList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>带头结点的单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">//初始化一个单链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;             <span class="comment">//内存不足</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                         <span class="comment">//头结点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;<span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(L-next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList L;                             <span class="comment">//申明一个指向单链表的指针</span></span><br><span class="line">    InitList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-单链表上基本操作的实现"><a href="#2-3-2-单链表上基本操作的实现" class="headerlink" title="2.3.2 单链表上基本操作的实现"></a>2.3.2 单链表上基本操作的实现</h3><p><strong>按位序插入（带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemeType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;                                   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;                                  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                                      <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;            <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">//i值不合法</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                                <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>按位序插入（不带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemeType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;                                <span class="comment">//插入第一个结点的操作与其他结点操作不同        </span></span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;                                   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;                                  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                                      <span class="comment">//p指向第1个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;            <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------InsertNextNode(p,e);-----------</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">//i值不合法</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                                <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//---------------------------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>指定结点的后插操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span> <span class="params">(LNode *p,ElemeType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;                 <span class="comment">//内存分配失败</span></span><br><span class="line">    s-&gt;data = e;                                <span class="comment">//用结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                                <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p><strong>指定结点的前插操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在p结点之前插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p,ElemeType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                                <span class="comment">//新结点s连到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data;                          <span class="comment">//将p中元素复制到s中</span></span><br><span class="line">    p-&gt;data = e;                                <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p><strong>按位序删除（带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作，删除表L中的第i个位置的元素，并用e返回删除元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i, ElemeType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* p;                                   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;                                  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                                      <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;            <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;                <span class="comment">//i值不合法</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;          <span class="comment">//第i-1个节点之后已无其他结点</span></span><br><span class="line">    LNode* q = p-&gt;next;                         <span class="comment">//令q指向被删除节点</span></span><br><span class="line">    e = q-&gt;data;                                <span class="comment">//用e返回元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;                          <span class="comment">//将*q节点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);                                    <span class="comment">//释放结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>指定结点的删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;                         <span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;                    <span class="comment">//和后继结点交换数据域，（最后一个结点会出错！！！）</span></span><br><span class="line">    p-&gt;next = q-&gt;next;                          <span class="comment">//将*q节点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p><strong>按位查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素（带头结点）</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;                                   <span class="comment">//指针p指向当前扫描的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;                                  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                                      <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;                 <span class="comment">//循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>按值查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域 == e的结点</span></span><br><span class="line"><span class="function">LNode * <span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;                     <span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;                               <span class="comment">//找到后返回，否则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>求表的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>尾插法建立单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));                    <span class="comment">//建立头结点</span></span><br><span class="line">    LNode* s, * r = L;                                      <span class="comment">//r位表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;                                     <span class="comment">//输入9999表示结束</span></span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;                                              <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                                         <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>头插法建立单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    LNode* s;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));                     <span class="comment">//建立头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                                          <span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;</span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));                  <span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;                                        <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-3-3-双链表"><a href="#2-3-3-双链表" class="headerlink" title="2.3.3 双链表"></a>2.3.3 双链表</h3><p><strong>定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>* <span class="title">prior</span>, * <span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br></pre></td></tr></table></figure>

<p><strong>双链表的初始化(带头结点)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkLIst</span><span class="params">(DLinklist&amp; L)</span> </span>&#123;</span><br><span class="line">    L = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));                      <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;                            <span class="comment">//内存不足，分配失败</span></span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;                                        <span class="comment">//头结点的prior永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                                         <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinkLIst(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode* p, DNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//非法参数</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)                                     <span class="comment">//如果p结点有后继结点</span></span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode* q = p-&gt;next;                                 <span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;                        <span class="comment">//p没有后继</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>)                                <span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryList</span><span class="params">(DLinklist&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    <span class="built_in">free</span>(L);                                            <span class="comment">//释放头结点</span></span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;              <span class="comment">//后项遍历</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;       </span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;               <span class="comment">//前项遍历</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>) &#123;       <span class="comment">//前项遍历（跳过头结点）</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
</search>
