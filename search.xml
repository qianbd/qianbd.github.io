<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About me</title>
    <url>/2020/06/01/about/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>A Coder, live in Hangzhou, China.</p>
</blockquote>
<p>姓名：gjw<br>昵称：千摆渡<br>现居：杭州某大学<br>QQ：1012198609</p>
<a id="more"></a>

<img src="https://i.loli.net/2020/06/01/fzOY4omdHrSBaj9.jpg" alt="avatar" width="300" style="border-radius:50%">
]]></content>
  </entry>
  <entry>
    <title>千摆渡的自我介绍</title>
    <url>/2020/06/01/%E5%8D%83%E6%91%86%E6%B8%A1%E7%9A%84%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浙江某不知名高校一计算机科学与技术的咸鱼学生，啥都不会的学生，去过QHD，NJ，SY的icpc现场（有点点怀念），现在正在准备考研之中，偶尔网上冲浪，喜欢看动漫，韩剧（没想到吧），偶尔打打游戏，还喜欢运动，健身（hhh），喜欢的音乐很多，不一一列举了。家住绍兴某一不知名古镇（安昌古镇）边上，放一张图</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/06/01/KYpI5Pt19gNfZFq.jpg" alt="IMG_7011.JPG"></p>
<p>其实也还可以啦，我感觉还不错。</p>
<p>既然放了家乡的照片，学校的照片怎么也得放几张了吧</p>
<p><img src="https://i.loli.net/2020/06/01/gt21Y5WZbRiBHwj.jpg" alt="IMG_0627.JPG"></p>
<p>然后自己呢，放一张没脸的照片吧hhh</p>
<p><img src="https://i.loli.net/2020/06/01/fzOY4omdHrSBaj9.jpg" alt="IMG_9195.JPG"></p>
]]></content>
      <categories>
        <category>闲话</category>
      </categories>
      <tags>
        <tag>自我介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——栈和队列</title>
    <url>/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><h2 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h2><h3 id="3-1-1-栈的基本概念"><a href="#3-1-1-栈的基本概念" class="headerlink" title="3.1.1 栈的基本概念"></a>3.1.1 栈的基本概念</h3><a id="more"></a>
<p>1.栈的定义：只允许在一端进行插入或删除操作的线性表<br>n个不同的元素进栈，出栈元素不同排列的个数为 <img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/pic2.jpg" alt="picture_3"><br>2.栈的基本操作：</p>
<ul>
<li>InitStack(&amp;S):初始化一个空栈</li>
<li>StackEmpty(S):判断栈空，空返回true，否则返回false</li>
<li>Push(&amp;S,x):进栈，若栈S未满，则将x加入使之成为新栈顶</li>
<li>Pop(&amp;S,&amp;x):出栈，若栈未空，则弹出栈顶元素，并用x返回</li>
<li>GetTop(S,&amp;x):读栈顶元素</li>
<li>DestroyStack(&amp;S):销毁栈</li>
</ul>
<h3 id="3-1-2-栈的顺序存储结构"><a href="#3-1-2-栈的顺序存储结构" class="headerlink" title="3.1.2 栈的顺序存储结构"></a>3.1.2 栈的顺序存储结构</h3><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;    <span class="comment">//初始化</span></span><br><span class="line">    S.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == MaxSize - <span class="number">1</span>)       <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S.data[++S.top] = x;            <span class="comment">//指针先加1，再入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top--];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读栈顶元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共享栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top0,top1;  <span class="comment">//0号栈栈顶指针，1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;</span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈满的条件： top0 + 1 == top1</p>
<h3 id="3-1-3-栈的链式存储实现"><a href="#3-1-3-栈的链式存储实现" class="headerlink" title="3.1.3 栈的链式存储实现"></a>3.1.3 栈的链式存储实现</h3><p>定义(类似于单链表)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *LiStack;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h2><h3 id="3-2-1-队列的基本概念"><a href="#3-2-1-队列的基本概念" class="headerlink" title="3.2.1 队列的基本概念"></a>3.2.1 队列的基本概念</h3><p>1.队列的定义：只允许在表的一端进行插入，而在表的另一端进行删除<br>2.队列的基本操作<br>InitQueue(&amp;Q):初始化队列，构造一个空队列Q。DestroyQueue(&amp;Q):销毁队列。销毁并释放队列Q所占用的内存空间。<br>EnQueue(&amp;Q ,x):若队列Q未满，将x加入，使之成为新的队尾<br>DeQueue(&amp;Q ,&amp;x):若队列Q非空，删除队头元素，并用x返回。<br>GetHead(Q ,&amp;x):读队头元素，若队列Q非空，则将队头元素赋值给x</p>
<h3 id="3-2-2-队列的顺序存储结构"><a href="#3-2-2-队列的顺序存储结构" class="headerlink" title="3.2.2 队列的顺序存储结构"></a>3.2.2 队列的顺序存储结构</h3><p>1.队列的顺序存储</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判队空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MaxSize == Q.front) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//队满</span></span><br><span class="line">    Q.data[Q.rear] = x;</span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判满需要浪费一个单元的存储空间，若不能浪费，则类型中增加数据size或者添加tag(详情P79)</span></span><br></pre></td></tr></table></figure>
<p>出队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-队列的链式存储结构"><a href="#3-2-3-队列的链式存储结构" class="headerlink" title="3.2.3 队列的链式存储结构"></a>3.2.3 队列的链式存储结构</h3><p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判队空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队（带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next = s;       <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear = s;             <span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素入队（不带头结点）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>) &#123;       <span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;</span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Q.rear-&gt;next = s;       <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">        Q.rear = s;             <span class="comment">//修改表尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队(带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p-&gt;data;                    <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front-&gt;next = p-&gt;next;        <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)                 <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.rear = Q.front;           <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队(不带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front;          <span class="comment">//p指向此次出队的结点</span></span><br><span class="line">    x = p-&gt;data;                    <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next;              <span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) &#123;               <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.front = <span class="literal">NULL</span>;             <span class="comment">//front和rear指向NULL</span></span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;                               </span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-双端队列"><a href="#3-2-4-双端队列" class="headerlink" title="3.2.4 双端队列"></a>3.2.4 双端队列</h3><p>允许两端都可以进行入队和出队操作的队列</p>
<h2 id="3-3-栈和队列的应用"><a href="#3-3-栈和队列的应用" class="headerlink" title="3.3 栈和队列的应用"></a>3.3 栈和队列的应用</h2><h3 id="3-3-1-栈在括号匹配中的应用"><a href="#3-3-1-栈在括号匹配中的应用" class="headerlink" title="3.3.1 栈在括号匹配中的应用"></a>3.3.1 栈在括号匹配中的应用</h3><p>用栈实现括号匹配:<br>依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配。</p>
<p>匹配失败情况:</p>
<ol>
<li>左括号单身</li>
<li>右括号单身</li>
<li>左右括号不匹配</li>
</ol>
<h3 id="3-3-2-栈在表达式求值中的应用"><a href="#3-3-2-栈在表达式求值中的应用" class="headerlink" title="3.3.2 栈在表达式求值中的应用"></a>3.3.2 栈在表达式求值中的应用</h3><table>
<thead>
<tr>
<th>中缀表达式</th>
<th>后缀表达式</th>
<th>前缀表达式</th>
</tr>
</thead>
<tbody><tr>
<td>a + b</td>
<td>a b +</td>
<td>+ a b</td>
</tr>
<tr>
<td>a + b - c</td>
<td>a b + c -</td>
<td>- + a b c</td>
</tr>
<tr>
<td>a + b - c * d</td>
<td>a b + c d * -</td>
<td>- + a b * c d</td>
</tr>
</tbody></table>
<p><strong>中缀转后缀的手算方法:</strong></p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数 </li>
<li>如果还有运算符没被处理，就继续2</li>
</ol>
<blockquote>
<p>“左优先”原则:只要左边的运算符能先计算，就优先算左边的(能保证运算顺序唯一)</p>
</blockquote>
<p><img src="/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/pic1.jpg" alt="picture_1"></p>
<p><strong>后缀表达式的手算方法:</strong><br>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数</p>
<blockquote>
<p>注意:两个操作数的左右顺序</p>
</blockquote>
<p><strong>后缀表达式的机算方法</strong><br>用栈实现后缀表达式的计算:</p>
<ol>
<li>从左往右扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，并回到1;否则执行3</li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1</li>
</ol>
<p><strong>中缀表达式转前缀表达式(手算)</strong><br>中缀转前缀的手算方法:</p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数 </li>
<li>如果还有运算符没被处理，就继续2<blockquote>
<p>“右优先”原则:只要右边的运算符能先计算，就优先算右边的</p>
</blockquote>
</li>
</ol>
<p><strong>前缀表达式的机算方法</strong><br>用栈实现前缀表达式的计算:</p>
<ol>
<li>从右往左扫描下一个元素，直到处理完所有元素</li>
<li>若扫描到操作数则压入栈，并回到1;否则执行3</li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1</li>
</ol>
<p><strong>中缀表达式转后缀表达式(机算)</strong><br>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。<br>从左到右处理各个元素，直到末尾。可能遇到三种情况:</p>
<ul>
<li>遇到操作数。直接加入后缀表达式。</li>
<li>遇到界限符。遇到“(”直接入栈;遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到 弹出“(”为止。注意:“(”不加入后缀表达式。</li>
<li>遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式， 若碰到“(” 或栈空则停止。之后再把当前运算符入栈。</li>
</ul>
<p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<p><strong>中缀表达式的计算(用栈实现)</strong><br>用栈实现中缀表达式的计算:</p>
<ul>
<li>初始化两个栈，操作数栈和运算符栈</li>
<li>若扫描到操作数，压入操作数栈</li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈(期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈)</li>
</ul>
<h3 id="3-3-3-栈在递归中的应用"><a href="#3-3-3-栈在递归中的应用" class="headerlink" title="3.3.3 栈在递归中的应用"></a>3.3.3 栈在递归中的应用</h3><p>递归条件</p>
<ul>
<li>递归表达式（递归体）</li>
<li>边界条件（递归出口）</li>
</ul>
<p>函数调用的特点:最后被调用的函数最先执行结束(LIFO)<br>函数调用时，需要用一个“函数调用栈” 存储: </p>
<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——串</title>
    <url>/2020/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第四章-串"><a href="#第四章-串" class="headerlink" title="第四章 串"></a>第四章 串</h1><h2 id="4-1-串的定义和实现"><a href="#4-1-串的定义和实现" class="headerlink" title="4.1 串的定义和实现"></a>4.1 串的定义和实现</h2><h3 id="4-1-1-串的定义"><a href="#4-1-1-串的定义" class="headerlink" title="4.1.1 串的定义"></a>4.1.1 串的定义</h3><a id="more"></a>
<p>串(string)是由零个或多个字符组成的有限序列。一般记为<br><strong><center>S = ‘a<sub>1</sub>a<sub>2</sub>…a<sub>n</sub>‘(n&gt;=0)</center></strong></p>
<p>子串：串中任意个连续的字符组成的子序列<br>主串：包含子串的串</p>
<h3 id="4-1-2-串的存储结构"><a href="#4-1-2-串的存储结构" class="headerlink" title="4.1.2 串的存储结构"></a>4.1.2 串的存储结构</h3><p><strong>1.定长顺序存储表示</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>
<p>串长两种表示方法</p>
<ul>
<li>用一个额外的变量len来存放串的长度</li>
<li>在串值后面加一个不计入串长的结束标记字符”\0”，此时的串长为隐含值</li>
</ul>
<p><strong>2.堆分配存储方式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;       <span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>
<p>用malloc()和free()函数来完成动态存储管理。</p>
<p><strong>块链存储表示</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Chunk;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-串的基本操作"><a href="#4-1-3-串的基本操作" class="headerlink" title="4.1.3 串的基本操作"></a>4.1.3 串的基本操作</h3><ul>
<li>StrAssign(&amp;T,chars)：赋值操作。把串T赋值为chars</li>
<li>StrCopy(&amp;T,S)：复制操作，S复制得T</li>
<li>StrEmpty(S)：判空操纵，空返回TRUE</li>
<li>StrCompare(S,T)：比较操作，S&gt;T，返回值&gt;0，S&lt;T，返回值&lt;0，S=T，返回值=0</li>
<li>StrLength(S)：求串长</li>
<li>SubString(&amp;Sub,S,pos,len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串</li>
<li>Concat(&amp;T,S1,S2)：串联接</li>
<li>Index(S,T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置，否则函数值为0</li>
<li>CleanString(&amp;S)：清空操作。将S清为空串</li>
<li>DestroyString(&amp;S)：销毁串</li>
</ul>
<h2 id="4-2-串的模式匹配"><a href="#4-2-串的模式匹配" class="headerlink" title="4.2 串的模式匹配"></a>4.2 串的模式匹配</h2><h3 id="4-2-1-简单的模式匹配算法"><a href="#4-2-1-简单的模式匹配算法" class="headerlink" title="4.2.1 简单的模式匹配算法"></a>4.2.1 简单的模式匹配算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index</span><span class="params">(SString S,SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;         <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;             <span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-改进的模式匹配算法——KMP算法"><a href="#4-2-2-改进的模式匹配算法——KMP算法" class="headerlink" title="4.2.2 改进的模式匹配算法——KMP算法"></a>4.2.2 改进的模式匹配算法——KMP算法</h3><p><strong>next[j]的含义</strong>： 在子串的第j个字符与主串发生失配时，则跳到子串的next[j]位置重新与主串当前位置进行比较<br>|  编号   | 1 | 2 | 3 | 4 | 5 |<br>|  –  | –  | – | – | – | –|<br>| S  | a | b | c | a | c |<br>| next| 0 | 1 | 1 | 1 | 2 |</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(SString T,<span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;            <span class="comment">//若pi = pj,则next[j+1]=next[j]+1</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S,SString T,<span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;   </span><br><span class="line">            ++j;                    <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            j = next[j];            <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)                <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i - T.length; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-KMP算法的进一步优化"><a href="#4-2-3-KMP算法的进一步优化" class="headerlink" title="4.2.3 KMP算法的进一步优化"></a>4.2.3 KMP算法的进一步优化</h3><table>
<thead>
<tr>
<th>主串</th>
<th>a</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>a</th>
</tr>
</thead>
<tbody><tr>
<td>模式</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>b</td>
</tr>
<tr>
<td>j</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>nextval[j]</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>
</tbody></table>
<blockquote>
<p>当i=4、j=4时，s<sub>4</sub>跟p<sub>4</sub>(b!=a)失配，如果用之前的next数组还需要进行s<sub>4</sub>与p<sub>3</sub>，s<sub>4</sub>与p<sub>2</sub>，s<sub>4</sub>与p<sub>1</sub>这三次比较，事实上，p<sub>next[4]=3</sub>=p<sub>4</sub>=a、p<sub>next[2]=1</sub>=p<sub>2</sub>=a，显然后面3次用一个和p<sub>4</sub>相同的字符跟s<sub>4</sub>比较毫无意义，必然失配。问题在于不应该出现p<sub>j</sub>=p<sub>next[j]</sub>，理由是p<sub>j</sub>!=s<sub>j</sub>时，下次的匹配必然是p<sub>next[j]</sub>跟s<sub>j</sub>比较，如果p<sub>j</sub>=p<sub>next[j]</sub>，那么相当于拿一个和p<sub>j</sub>相等的字符跟s<sub>j</sub>比较，这必然导致继续失配。因此，如果出现了p<sub>j</sub>=p<sub>next[j]</sub>，则需要再次递归，将next[j]修正为next[next[j]]，直至两者不相等为止，更新后的数组命名为nextval</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_nextval</span><span class="params">(SString T,<span class="keyword">int</span> nextval[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;</span><br><span class="line">    nextval[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span>(T.ch[i] != T.ch[j])</span><br><span class="line">                nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nextval[i] = nextval[j];</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            j = nextval[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——树与二叉树</title>
    <url>/2020/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第五章-树与二叉树"><a href="#第五章-树与二叉树" class="headerlink" title="第五章 树与二叉树"></a>第五章 树与二叉树</h1><h2 id="5-1-树的基本概念"><a href="#5-1-树的基本概念" class="headerlink" title="5.1 树的基本概念"></a>5.1 树的基本概念</h2><h3 id="5-1-1-树的定义"><a href="#5-1-1-树的定义" class="headerlink" title="5.1.1 树的定义"></a>5.1.1 树的定义</h3><a id="more"></a>
<p>树是n(n&gt;=0)个节点的有限集。当n=0，称为<strong>空树</strong>。在任意的一颗非空树中应满足</p>
<ul>
<li>有且仅有一个特定的称为根的结点</li>
<li>当n&gt;1时，其余节点可分为m(m&gt;0)个互不相交的有限集T<sub>1</sub>，T<sub>2</sub>…T<sub>m</sub>，其中每个集合本身又是一棵树，并且称为根的<strong>子树</strong></li>
</ul>
<p>树的特点：</p>
<ul>
<li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱</li>
<li>树中所有结点可以有零个或多个后继</li>
</ul>
<h3 id="5-1-2-基本术语"><a href="#5-1-2-基本术语" class="headerlink" title="5.1.2 基本术语"></a>5.1.2 基本术语</h3><p><strong>祖先、子孙、双亲、孩子、兄弟、堂兄弟</strong><br><strong>结点的度、树的度、叶子结点、树的高度(或深度)、结点的高度和深度、路径长度</strong><br><strong>有序树、无序树、森林</strong></p>
<blockquote>
<p>见王道书P125<br>度为m的树至少有一个结点度为m，m叉树只要所有的结点度数&lt;=m即可</p>
</blockquote>
<h3 id="5-1-3-树的性质"><a href="#5-1-3-树的性质" class="headerlink" title="5.1.3 树的性质"></a>5.1.3 树的性质</h3><ul>
<li>树中的结点数等于所有结点的度数加1</li>
<li>度为m的树中第i层至多有m^(i-1)个结点(i&gt;=1)</li>
<li>高度为h的m叉树至多有(m^h-1)/(m-1)个结点</li>
<li>具有n个结点的m叉树的最小高度为ceil(log m (n(m-1)+1))</li>
</ul>
<h2 id="5-2-二叉树的概念"><a href="#5-2-二叉树的概念" class="headerlink" title="5.2 二叉树的概念"></a>5.2 二叉树的概念</h2><h3 id="5-2-1-二叉树的定义及其主要特性"><a href="#5-2-1-二叉树的定义及其主要特性" class="headerlink" title="5.2.1 二叉树的定义及其主要特性"></a>5.2.1 二叉树的定义及其主要特性</h3><p><strong>1.二叉树的定义</strong><br>每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒<br><strong>2.几个特殊的二叉树</strong></p>
<ul>
<li>满二叉树：高度为h，且含有2^h-1个结点的二叉树</li>
<li>完全二叉树：高度为h，有n个结点，每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应</li>
<li>二叉排序树：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树</li>
<li>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1</li>
</ul>
<p><strong>3.二叉树的性质</strong></p>
<ul>
<li>非空二叉树上的叶子结点数等于度为2的结点数加1，即n<sub>0</sub> = n<sub>2</sub> + 1</li>
<li>非空二叉树上第k层至多有2^(k-1)个结点</li>
<li>高度为h的二叉树至多有2^k - 1个结点</li>
<li>对完全二叉树按从上到下、从左到右的顺序依次编号1，2，…，n，则有以下关系<ul>
<li>当i&gt;1,结点双亲编号为i/2</li>
<li>当2i&lt;=n时，结点i的左孩子编号为2i，否则无左孩子</li>
<li>当2i+1&lt;=n时，结点i的右孩子编号为2i，否则无右孩子</li>
<li>结点i所在层次(深度)为(int)(log 2 i) + 1</li>
<li>具有n个结点的完全二叉树的高度为ceil(log 2 n+ 1) 或 int(log 2 n) + 1</li>
</ul>
</li>
</ul>
<h3 id="5-2-2-二叉树的存储结构"><a href="#5-2-2-二叉树的存储结构" class="headerlink" title="5.2.2 二叉树的存储结构"></a>5.2.2 二叉树的存储结构</h3><p><strong>1.顺序存储结构</strong><br>一组地址连续的存储但愿依次自上而下、自左至右存储完全二叉树上的结点元素。<br><strong>2.链式存储结构</strong><br>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line">BiTree root = <span class="literal">NULL</span>; <span class="comment">//定义一棵空树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入根结点</span></span><br><span class="line">    root = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (BiTNode));</span><br><span class="line">    root-&gt;data =&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;rchild = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="comment">//插入新结点</span></span><br><span class="line">    BiTNode *p = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;lchild = p;   <span class="comment">//作为根结点的左孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求树的深度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">        <span class="keyword">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> l&gt;r ? l+<span class="number">1</span> : r+<span class="number">1</span>;     <span class="comment">//树的深度=Max(左子树深度，右子树深度) + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-二叉树的遍历和线索二叉树"><a href="#5-3-二叉树的遍历和线索二叉树" class="headerlink" title="5.3 二叉树的遍历和线索二叉树"></a>5.3 二叉树的遍历和线索二叉树</h2><h3 id="5-3-1-二叉树的遍历"><a href="#5-3-1-二叉树的遍历" class="headerlink" title="5.3.1 二叉树的遍历"></a>5.3.1 二叉树的遍历</h3><p><strong>1.先序遍历</strong><br>访问根结点，先序遍历左子树，先序遍历右子树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.中序遍历</strong><br>中序遍历左子树，访问根结点，中序遍历右子树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.后序遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.递归算法和非递归算法的转换</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    InitStack(S);   BiTree p = T;   <span class="comment">//初始化栈S，p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S)) &#123;       <span class="comment">//栈不空或p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p) &#123;                     <span class="comment">//一路向左</span></span><br><span class="line">            Push(S,p);              <span class="comment">//当前结点入栈</span></span><br><span class="line">            p=p-&gt;lchild;            <span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">            Pop(S,p);   visit(p);   <span class="comment">//栈顶元素出栈， 访问出栈结点</span></span><br><span class="line">            p = p-&gt;rchild;          <span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder2</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    InitStack(S);   BiTree p = T;   <span class="comment">//初始化栈S，p是遍历指针</span></span><br><span class="line">    <span class="keyword">while</span>(p || !IsEmpty(S)) &#123;       <span class="comment">//栈不空或p不空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p) &#123;                     <span class="comment">//一路向左</span></span><br><span class="line">            visit(p);   Push(S,p);  <span class="comment">//访问当前结点，并入栈</span></span><br><span class="line">            p=p-&gt;lchild;            <span class="comment">//左孩子不空，一直向左走</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                    <span class="comment">//出栈，并转向出栈结点的右子树</span></span><br><span class="line">            Pop(S,p);              <span class="comment">//栈顶元素出栈</span></span><br><span class="line">            p = p-&gt;rchild;          <span class="comment">//向右子树走，p赋值为当前结点的右孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.层次遍历</strong><br>算法思想：<br>1.初始化一个辅助队列<br>2.根结点入队<br>3.若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾(如果有的话)<br>4.重复3直至队列为空</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);           <span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q)) &#123;    <span class="comment">//队列不空则循环</span></span><br><span class="line">        DeQueue(Q,p);       <span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);           <span class="comment">//  访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>) </span><br><span class="line">            EnQueue(Q,p-&gt;lchild);   <span class="comment">//左子树不空，则左子树根结点入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;rchild);   <span class="comment">//右子树不空，则右子树根结点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.由遍历序列构造二叉树</strong><br>由中序序列和先序序列、后序序列、层序序列三个之一就可唯一确定一棵二叉树</p>
<h3 id="5-3-2-线索二叉树"><a href="#5-3-2-线索二叉树" class="headerlink" title="5.3.2 线索二叉树"></a>5.3.2 线索二叉树</h3><p><strong>1.线索二叉树的基本概念</strong><br>若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点，还需增加两个标志域标识指针域是指向左(右)孩子还是指向前驱(后继)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>
<p><strong>2.中序线索二叉树的构造</strong><br>通过中序遍历对二叉树线索化的递归算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InThread(p-&gt;rchild,pre);    <span class="comment">//递归，线索化左子树</span></span><br><span class="line">        <span class="comment">//--------visit--------</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>) &#123;     <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;        </span><br><span class="line">            pre-&gt;rchild = p;        <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;                    <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span><br><span class="line">        <span class="comment">//--------visit--------</span></span><br><span class="line">        InThread(p-&gt;rchild,pre);    <span class="comment">//递归，线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过中序遍历建立中序线索二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;                 <span class="comment">//非空二叉树，线索化</span></span><br><span class="line">        InThread(T,pre);            <span class="comment">//线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;         <span class="comment">//处理遍历的最后一个结点，中序遍历最后一个结点的右孩子必然为空</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先序线索化(王道教材style)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//--------visit--------</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>) &#123;     <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;        </span><br><span class="line">            pre-&gt;rchild = p;        <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;                    <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span><br><span class="line">        <span class="comment">//--------visit--------</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">            PreThread(p-&gt;lchild,pre);</span><br><span class="line">        PreThread(p-&gt;rchild,pre);    <span class="comment">//递归，线索化右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;                 <span class="comment">//非空二叉树，线索化</span></span><br><span class="line">        PreThread(T,pre);            <span class="comment">//线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后序线索化(王道教材style)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree &amp;p,ThreadTree &amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PostThread(p-&gt;lchild,pre);</span><br><span class="line">        PostThread(p-&gt;rchild,pre);</span><br><span class="line">        <span class="comment">//--------visit--------</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>) &#123;     <span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;        </span><br><span class="line">            pre-&gt;rchild = p;        <span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;                    <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span><br><span class="line">        <span class="comment">//--------visit--------</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>) &#123;                 <span class="comment">//非空二叉树，线索化</span></span><br><span class="line">        PostThread(T,pre);            <span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild = <span class="literal">NULL</span>)         <span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.中序线索二叉树的遍历</strong><br>求中序线索二叉树中中序序列下的第一个结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求中序线索二叉树中结点p在中序序列下的后继</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">Nexttnode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;       <span class="comment">//rtag=1直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不含头结点的中序线索二叉树的中序遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode *T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = Firstnode(T); p != <span class="literal">NULL</span>; p = Nexttnode(p))</span><br><span class="line">        visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-树、森林"><a href="#5-4-树、森林" class="headerlink" title="5.4 树、森林"></a>5.4 树、森林</h2><h3 id="5-4-1-树的存储结构"><a href="#5-4-1-树的存储结构" class="headerlink" title="5.4.1 树的存储结构"></a>5.4.1 树的存储结构</h3><p><strong>1.双亲表示法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>             <span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;             <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>             <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;                  <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/pare.jpg" alt="picture_1"></p>
<p><strong>2.孩子表示法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;              <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>    <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>  <span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZES];</span><br><span class="line">    <span class="keyword">int</span> n,r;            <span class="comment">//结点树和根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/h.jpg" alt="picture_2"><br><strong>3.孩子兄弟表示法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span> <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/x.jpg" alt="picture_3"></p>
<h3 id="5-4-2-树、森林与二叉树的转换"><a href="#5-4-2-树、森林与二叉树的转换" class="headerlink" title="5.4.2 树、森林与二叉树的转换"></a>5.4.2 树、森林与二叉树的转换</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——线性表</title>
    <url>/2020/06/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><h2 id="2-1-线性表的定义和基本操作"><a href="#2-1-线性表的定义和基本操作" class="headerlink" title="2.1 线性表的定义和基本操作"></a>2.1 线性表的定义和基本操作</h2><h3 id="2-1-1-线性表的定义"><a href="#2-1-1-线性表的定义" class="headerlink" title="2.1.1 线性表的定义"></a>2.1.1 线性表的定义</h3><a id="more"></a>
<p><strong>线性表</strong>是具有<strong>相同数据类型</strong>的n个数据元素的<strong>有限</strong>序列，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则其一般表示为<br><strong><center>L = (a<sub>1</sub>,a<sub>2</sub>…a<sub>i</sub>,a<sub>i+1</sub>…,a<sub>n</sub>)</center></strong></p>
<ul>
<li>a<sub>1</sub>:表头元素</li>
<li>a<sub>n</sub>:表尾元素</li>
</ul>
<p>除第一个元素外，每个元素<strong>有且仅有</strong>一个<strong>直接前驱</strong><br>除最后一个元素外，每个元素<strong>有且仅有</strong>一个<strong>直接后继</strong></p>
<p>特点</p>
<ul>
<li>表中元素的个数有限</li>
<li>表中元素具有逻辑上的顺序性，表中元素有其先后次序</li>
<li>表中元素都是数据元素，每个元素都是单个元素</li>
<li>表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间</li>
<li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容</li>
</ul>
<hr>
<h2 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的顺序表示</h2><h3 id="2-2-1-顺序表的定义"><a href="#2-2-1-顺序表的定义" class="headerlink" title="2.2.1 顺序表的定义"></a>2.2.1 顺序表的定义</h3><p>线性表是具有相同数据类型的n (n≥0)个数据元素的<strong>有限</strong>序列</p>
<p>特点：表中元素的逻辑顺序与其物理顺序相同</p>
<h4 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50              <span class="comment">//定义的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                </span><br><span class="line">    ElemType data[MaxSize];     <span class="comment">//顺序表的元素</span></span><br><span class="line">    <span class="keyword">int</span> length;                 <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                        <span class="comment">//顺序表的类型定义</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化一个线性表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50             </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>                </span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];     </span><br><span class="line">    <span class="keyword">int</span> length;                 </span><br><span class="line">&#125;SqList; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) </span><br><span class="line">        L.data[i] = <span class="number">0</span>;          <span class="comment">//将所有数据元素设置为默认值</span></span><br><span class="line">    L.length = <span class="number">0</span>;               <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    InitList(L);</span><br><span class="line">   <span class="comment">// ...未完待续</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;：对参数的修改结果需要带回来</p>
<h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10             <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *data;             <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;                 <span class="comment">//顺序表的类型定义（动态分配方式）</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure>
<p><strong>动态增加数组的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitSize 10             <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *data;                  <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;                <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;                 <span class="comment">//顺序表的类型定义（动态分配方式）</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));   <span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L,<span class="keyword">int</span> len)</span> </span>&#123;             <span class="comment">//增加动态数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> *p = L.data;</span><br><span class="line">    L.data = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>((L.MaxSize +　len)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; L.length; i++) &#123;</span><br><span class="line">        L.data[i] = p[i];                           <span class="comment">//将数据复制到新区域（时间开销大）</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = L.MaxSize + len;                    <span class="comment">//顺序表最大长度增加len</span></span><br><span class="line">    <span class="built_in">free</span>(p);                                        <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>malloc和free函数的头文件<code>#include&lt;stdlib.h&gt;</code></p>
<h3 id="2-2-2-顺序表上基本操作的实现"><a href="#2-2-2-顺序表上基本操作的实现" class="headerlink" title="2.2.2 顺序表上基本操作的实现"></a>2.2.2 顺序表上基本操作的实现</h3><p><strong>插入操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElemeType int             </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemeType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在顺序表L的第i个位置插入新元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)          <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= MaxSize)                <span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = L.length; j &gt;= i; j--)     <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;                      <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;                             <span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>删除操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(SqList&amp; L, <span class="keyword">int</span> i, <span class="keyword">int</span>&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)          <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i - <span class="number">1</span>];                      <span class="comment">//将被删除的的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; L.length; j++)      <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    L.length--;                             <span class="comment">//线性表的长度减1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>按位查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p><strong>按值查找（顺序查找）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == e)          <span class="comment">//下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<hr>
<h2 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h2><h3 id="2-3-1-单链表的定义"><a href="#2-3-1-单链表的定义" class="headerlink" title="2.3.1 单链表的定义"></a>2.3.1 单链表的定义</h3><p><strong>定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>
<p><strong>不带头结点的单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;<span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">return</span> (L == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList L;                             <span class="comment">//申明一个指向单链表的指针</span></span><br><span class="line">    InitList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>带头结点的单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"><span class="comment">//初始化一个单链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;             <span class="comment">//内存不足</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                         <span class="comment">//头结点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;<span class="comment">//判空</span></span><br><span class="line">    <span class="keyword">if</span>(L-next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList L;                             <span class="comment">//申明一个指向单链表的指针</span></span><br><span class="line">    InitList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-单链表上基本操作的实现"><a href="#2-3-2-单链表上基本操作的实现" class="headerlink" title="2.3.2 单链表上基本操作的实现"></a>2.3.2 单链表上基本操作的实现</h3><p><strong>按位序插入（带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemeType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;                                   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;                                  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                                      <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;            <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">//i值不合法</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                                <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>按位序插入（不带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemeType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;                                <span class="comment">//插入第一个结点的操作与其他结点操作不同        </span></span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;                                   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;                                  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                                      <span class="comment">//p指向第1个结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;            <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-------InsertNextNode(p,e);-----------</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                           <span class="comment">//i值不合法</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                                <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//---------------------------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>指定结点的后插操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextNode</span> <span class="params">(LNode *p,ElemeType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;                 <span class="comment">//内存分配失败</span></span><br><span class="line">    s-&gt;data = e;                                <span class="comment">//用结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                                <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p><strong>指定结点的前插操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在p结点之前插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertPriorNode</span><span class="params">(LNode *p,ElemeType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;                                <span class="comment">//新结点s连到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data;                          <span class="comment">//将p中元素复制到s中</span></span><br><span class="line">    p-&gt;data = e;                                <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p><strong>按位序删除（带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作，删除表L中的第i个位置的元素，并用e返回删除元素的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList&amp; L, <span class="keyword">int</span> i, ElemeType&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode* p;                                   <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;                                  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                                      <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;            <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;                <span class="comment">//i值不合法</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;          <span class="comment">//第i-1个节点之后已无其他结点</span></span><br><span class="line">    LNode* q = p-&gt;next;                         <span class="comment">//令q指向被删除节点</span></span><br><span class="line">    e = q-&gt;data;                                <span class="comment">//用e返回元素的值</span></span><br><span class="line">    p-&gt;next = q-&gt;next;                          <span class="comment">//将*q节点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);                                    <span class="comment">//释放结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>指定结点的删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;                         <span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;                    <span class="comment">//和后继结点交换数据域，（最后一个结点会出错！！！）</span></span><br><span class="line">    p-&gt;next = q-&gt;next;                          <span class="comment">//将*q节点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(1)</p>
<p><strong>按位查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素（带头结点）</span></span><br><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;                                   <span class="comment">//指针p指向当前扫描的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;                                  <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;                                      <span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) &#123;                 <span class="comment">//循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>按值查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域 == e的结点</span></span><br><span class="line"><span class="function">LNode * <span class="title">LocateElem</span><span class="params">(LinkList L,ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;                     <span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;                               <span class="comment">//找到后返回，否则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>求表的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n)</p>
<p><strong>尾插法建立单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));                    <span class="comment">//建立头结点</span></span><br><span class="line">    LNode* s, * r = L;                                      <span class="comment">//r位表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;                                     <span class="comment">//输入9999表示结束</span></span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;                                              <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;                                         <span class="comment">//尾结点指针置空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>头插法建立单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">    LNode* s;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));                     <span class="comment">//建立头结点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                                          <span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;</span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));                  <span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = s;                                        <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-3-3-双链表"><a href="#2-3-3-双链表" class="headerlink" title="2.3.3 双链表"></a>2.3.3 双链表</h3><p><strong>定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    ElemeType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>* <span class="title">prior</span>, * <span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br></pre></td></tr></table></figure>

<p><strong>双链表的初始化(带头结点)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkLIst</span><span class="params">(DLinklist&amp; L)</span> </span>&#123;</span><br><span class="line">    L = (DNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));                      <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;                            <span class="comment">//内存不足，分配失败</span></span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;                                        <span class="comment">//头结点的prior永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                                         <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DLinklist L;</span><br><span class="line">    InitDLinkLIst(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode* p, DNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;               <span class="comment">//非法参数</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)                                     <span class="comment">//如果p结点有后继结点</span></span><br><span class="line">        p-&gt;next-&gt;prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode* q = p-&gt;next;                                 <span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;                        <span class="comment">//p没有后继</span></span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next != <span class="literal">NULL</span>)                                <span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryList</span><span class="params">(DLinklist&amp; L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        DeleteNextDNode(L);</span><br><span class="line">    <span class="built_in">free</span>(L);                                            <span class="comment">//释放头结点</span></span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;              <span class="comment">//后项遍历</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">&#125;       </span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;               <span class="comment">//前项遍历</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>) &#123;       <span class="comment">//前项遍历（跳过头结点）</span></span><br><span class="line">    p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构——绪论</title>
    <url>/2020/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h2><h3 id="1-1-1-基本概念和术语"><a href="#1-1-1-基本概念和术语" class="headerlink" title="1.1.1 基本概念和术语"></a>1.1.1 基本概念和术语</h3><a id="more"></a>
<p>数据：信息的载体</p>
<p>数据元素：数据的基本单位，若干数据项组成</p>
<p>数据对象：具有<strong>相同性质</strong>的数据元素的集合</p>
<p>数据类型：一个值的集合和定义在集合上的一组操作</p>
<ul>
<li>原子类型：如int，bool</li>
<li>结构类型：如结构体。  <code>struct A{int a;int b};</code></li>
<li>抽象数据类型</li>
</ul>
<p>数据结构：相互之间存在一种或多种特定<strong>关系</strong>的集合</p>
<blockquote>
<p>数据对象是强调相同性质，数据结构是强调特定关系</p>
</blockquote>
<p><img src="/2020/06/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BB%AA%E8%AE%BA/a.jpg" alt="数据关系"></p>
<h3 id="1-1-2数据结构的三要素"><a href="#1-1-2数据结构的三要素" class="headerlink" title="1.1.2数据结构的三要素"></a>1.1.2数据结构的三要素</h3><p>数据的逻辑结构</p>
<ul>
<li>集合</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图状或网状结构</li>
</ul>
<p>数据的存储结构</p>
<ul>
<li>顺序存储：相邻的存储单元</li>
<li>链式存储：不要求物理位置相邻</li>
<li>索引存储：建立索引表</li>
<li>散列存储：关键字直接计算，又称哈希存储</li>
</ul>
<p>数据的运算</p>
<ul>
<li><p>运算的定义是针对逻辑结构的</p>
</li>
<li><p>运算的实现是针对存储结构的</p>
<hr>
</li>
</ul>
<h2 id="1-2-算法和算法评价"><a href="#1-2-算法和算法评价" class="headerlink" title="1.2 算法和算法评价"></a>1.2 算法和算法评价</h2><h3 id="1-2-1-算法的基本概念"><a href="#1-2-1-算法的基本概念" class="headerlink" title="1.2.1 算法的基本概念"></a>1.2.1 算法的基本概念</h3><p>程序=数据结构+算法</p>
<ul>
<li>数据结构是要处理的信息</li>
<li>算法是处理信息的步骤</li>
</ul>
<p>算法的特性</p>
<ul>
<li>有穷性：有穷时间完成</li>
<li>确定性：确切的含义，相同输入得到相同输出</li>
<li>可行性：有限次数</li>
<li>输入</li>
<li>输出</li>
</ul>
<p>好算法的目标</p>
<ul>
<li>正确性：正确的解决问题</li>
<li>可读性：良好的可读，帮助理解，无歧义</li>
<li>健壮性：非法数据，做出反应和处理</li>
<li>效率与低存储量需求：低时间，低存储</li>
</ul>
<h3 id="1-2-2-算法效率的度量"><a href="#1-2-2-算法效率的度量" class="headerlink" title="1.2.2 算法效率的度量"></a>1.2.2 算法效率的度量</h3><p>时间复杂度</p>
<ul>
<li>T(n) = O(f(n))</li>
</ul>
<p>运算规则：</p>
<ul>
<li>加法规则：T(n) = T<sub>1</sub>(n) + T<sub>2</sub>(n) = O(f(n)) + O(g(n)) = O(max(f(n),g(n)))</li>
<li>乘法规则：T(n) = T<sub>1</sub>(n) * T<sub>2</sub>(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n)) </li>
</ul>
<p>空间复杂度</p>
<ul>
<li>S(n) = O(g(n))</li>
</ul>
<p><strong>原地工作：算法所需的辅助空间为常量，即O(1)</strong></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>绪论</tag>
      </tags>
  </entry>
  <entry>
    <title>百度云倍速</title>
    <url>/2020/06/14/%E7%99%BE%E5%BA%A6%E4%BA%91%E5%80%8D%E9%80%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>百度云盘播放倍速需要VIP，考研党看视频课一倍速太慢需要提提速，又不想用插件，使用这个试试吧</p>
<a id="more"></a>
<p>浏览器：Chrome，火狐等</p>
<p>方法：打开检查中的console，以mac中的chrome为例如图：<br><img src="/2020/06/14/%E7%99%BE%E5%BA%A6%E4%BA%91%E5%80%8D%E9%80%9F/hello.jpg" alt="你想输入的替代文字"></p>
<p>输入如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">videojs.getPlayers(<span class="string">"video-player"</span>).html5player.tech_.setPlaybackRate(<span class="number">1.5</span>)</span><br></pre></td></tr></table></figure>

<p>1.5就是倍速，可以根据自己的要求改变</p>
<p><strong>PS：输入代码的时候必须要在视频播放的时候，先播放再放入代码并按下回车</strong></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>视频播放</tag>
      </tags>
  </entry>
</search>
